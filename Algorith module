#include <stdio.h>
#include <libpynq.h>
#include "../utils.h"
#define REFRESH_USEC 4000000

float stress_cry_f(float cry){
return 10.0+0.4*cry;
}
float stress_hb_f(float hb){
  return 10.0+0.5*(hb-60.0);
}
float compute_stress(float stress_cry,float stress_hb){
  if(stress_cry>=50.0) stress_cry=50.0;
  if(stress_cry<=0.0) stress_cry=0.0;
  if(stress_hb<=0.0) stress_hb=0.0; //If stress alg fails and goes out of bounds
  if(stress_cry>=100) stress_cry=50.0;
  if(stress_hb>=100) stress_hb=100.0;

  return (stress_cry+stress_hb)/2.0;
}


typedef struct{
    int x,y;
  }coord;
  
  coord queue[25];
  int front=0, back=0;
  
  //queue stuff//
  void add(coord P){
    queue[back++]=P;
  }
  coord feed(){
    return queue[front++];
  }
  //stop when done//
  int check_empty(){
    return front==back; 
  }
  //initialize matrix for visited coords//
  int visited[5][5]={0};
  //check if point is inside the bounds of the grid/no repeats//
  int valid(coord P, float stress_neighbour, float stress_parent){
    
    return P.x>=0 && P.x<=4 && P.y>=0 && P.y<=4 && stress_neighbour<stress_parent &&!visited[P.x][P.y];
  }

int main(void){
  init();
  uint32_t i;
  uint32_t j;
  uint32_t slave_address1 = 0x70;
  uint32_t slave_address2 = 0x71;
  uint32_t slave_address3 = 0x72;
  float stress_neighbour, stress_parent;
  float cry,hb, stress_cry, stress_hb;

    //master-slave code is a while loop so I have to ensert BFS in the loop//
  //link variables to given info from hb and crying (doc says type int)//
  coord start={4,0};// CORRECT COORDS!!!!!!!!!!!!!!!!!!
  add(start);
  visited[4][0]=1; //CORRECT COORDS!!!!!!!!!!!!!!!!!!!!!!

  //movement stuff//
  int dx[4]={1,-1,0,0};
  int dy[4]={0,0,1,-1};
  printf("Main");
  if (iic_read_register(IIC0, slave_address1, 0, (uint8_t *) &i, 4)) { // 4 bytes
      printf("register[%d]=error\n", 0);
    }
    if (i == 0) {
      uint8_t tt = 1;
      uint8_t *t = &tt;
      iic_write_register(IIC0, slave_address1, 0, t, 4);
      for (int reg=1; reg < 32; reg++) {
        iic_read_register(IIC0, slave_address1, reg, (uint8_t *) &i, 4);
        if (reg == 5){
          cry=i;
        }
      }
    }

     /**
     * Slave 2 (will be HEARTBEAT)
     */

    if (iic_read_register(IIC0, slave_address2, 0, (uint8_t *) &j, 4)) { // 4 bytes
      printf("register[%d]=error\n", 0);
    }
    if (j == 0) {
      uint8_t tt = 1;
      uint8_t *t = &tt;
      iic_write_register(IIC0, slave_address2, 0, t, 4);
      for (int reg=1; reg < 32; reg++) {
        iic_read_register(IIC0, slave_address2, reg, (uint8_t *) &j, 4);
        if (reg == 5){
          hb=i;
        }
      }
    }
    printf("REad both slaves");
    fflush(stdout);
    stress_cry=stress_cry_f(cry);
    stress_hb=stress_hb_f(hb);
    stress_parent = compute_stress(stress_cry, stress_hb);
  while(!check_empty()){ 
    printf("get into this while loop");
    coord current_point = feed(); //feeding point that is currently evaluated//
    printf("feed \n");
    for(int k=0; k<4; k++){
    /**
       * Slave 1 (will be hb)
       */

      // Check if there's anything new in the registers
      if (iic_read_register(IIC0, slave_address1, 0, (uint8_t *) &i, 4)) { // 4 bytes
        printf("register[%d]=error\n", 0);
        displayFillScreen(&display, RGB_BLACK);
        displayDrawString(&display, fx16G, 100, 100, (uint8_t *)"error", RGB_GREEN);
        break;
      }
      if (i == 0) {
        uint8_t tt = 1;
        uint8_t *t = &tt;
        printf("wazzaaaap");
        iic_write_register(IIC0, slave_address1, 0, t, 4);
        for (int reg=1; reg < 32; reg++) {
          iic_read_register(IIC0, slave_address1, reg, (uint8_t *) &i, 4);
          if (reg == 5){
            cry=i;
          }
        }
      }

      /**
       * Slave 2 (will be cry)
       */

      if (iic_read_register(IIC0, slave_address2, 0, (uint8_t *) &j, 4)) { // 4 bytes
        printf("register[%d]=error\n", 0);
        displayFillScreen(&display, RGB_BLACK);
        displayDrawString(&display, fx16G, 100, 100, (uint8_t *)"error", RGB_GREEN);
        break;
      }
      if (j == 0) {
        uint8_t tt = 1;
        uint8_t *t = &tt;
        iic_write_register(IIC0, slave_address2, 0, t, 4);
        for (int reg=1; reg < 32; reg++) {
          iic_read_register(IIC0, slave_address2, reg, (uint8_t *) &j, 4);
          if (reg == 5){
            hb=i;
          }
        }
      }

      fflush(stdout);




        coord neighbour;
        neighbour.x=current_point.x + dx[k];
        neighbour.y=current_point.y + dy[k];
        
        stress_cry=stress_cry_f(cry);
        stress_hb=stress_hb_f(hb);
        stress_neighbour=compute_stress(stress_cry, stress_hb);
        
        iic_reset(IIC0);

        sleep_msec(7000); //MAYBE REMOVE

        if(valid(neighbour,stress_neighbour,stress_parent)){
          visited[neighbour.x][neighbour.y]=1;
          add(neighbour);
          printf("coords:(%i,%i); move x:%i, y:%i\n", neighbour.x, neighbour.y, dx[k],dy[k]);
        

          iic_write_register(IIC0, slave_address3, 1, dx[k], 4);
          iic_write_register(IIC0, slave_address3, 2, dy[k], 4);
         // my_register_map[1] = dx[k]; // set value
         // my_register_map[2] = dy[k]; // set value
         // my_register_map[0] = 0; // tell master that they've not read the value
      
        }
    }

  } 

}